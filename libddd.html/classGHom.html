<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>DDD: GHom Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.9 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>GHom Class Reference</h1><!-- doxytag: class="GHom" -->This class is the base class representing a homomorphism over <a class="el" href="classDDD.html" title="This class is the public interface for manipulating Data Decision Diagrams.">DDD</a>.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="Hom_8h_source.html">Hom.h</a>&gt;</code>
<p>
<div class="dynheader">
Inheritance diagram for GHom:</div>
<div class="dynsection">
<p><center><img src="classGHom__inherit__graph.png" border="0" usemap="#GHom__inherit__map" alt="Inheritance graph"></center>
<map name="GHom__inherit__map">
<area shape="rect" id="node3" href="classHom.html" title="This is the user interface class to manipulate homomorphisms." alt="" coords="16,678,112,989"></map>
<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center></div>
<div class="dynheader">
Collaboration diagram for GHom:</div>
<div class="dynsection">
<p><center><img src="classGHom__coll__graph.png" border="0" usemap="#GHom__coll__map" alt="Collaboration graph"></center>
<map name="GHom__coll__map">
<area shape="rect" id="node2" href="class__GHom.html" title="The concrete data class for Homomorphisms." alt="" coords="5,6,123,351"></map>
<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center></div>

<p>
<a href="classGHom-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="classGDDD.html">GDDD</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGHom.html#a6dc06d4106df676eeffdd02a24928ea">NodeType</a></td></tr>

<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGHom.html#bea95e1c6d1d3c496bdfe72db17313c6">GHom</a> (const <a class="el" href="class__GHom.html">_GHom</a> *_h)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A uncontrolled constructor used in internals.  <a href="#bea95e1c6d1d3c496bdfe72db17313c6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGHom.html#3229c2d620541eaf310c1e8ac8430324">GHom</a> (<a class="el" href="class__GHom.html">_GHom</a> *_h)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">THIS VERSION IS DELIBERATELY UNIMPLEMENTED OTHERWISE bad calls like <a class="el" href="classGShom.html" title="This class is the base class for Homomorphisms over SDD.">GShom</a>(new myHom()) would promote to const <a class="el" href="class__GShom.html" title="The concrete data class for Homomorphisms.">_GShom</a> *_h and bypass unicity.  <a href="#3229c2d620541eaf310c1e8ac8430324"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGHom.html#e37412107f59f9297138936dc0b91df5">GHom</a> (const <a class="el" href="class__GHom.html">_GHom</a> &amp;_h)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">build a <a class="el" href="classGHom.html" title="This class is the base class representing a homomorphism over DDD.">GHom</a> from user provided homomorphisms such as <a class="el" href="classStrongHom.html" title="The abstract base class for user defined operations.">StrongHom</a>.  <a href="#e37412107f59f9297138936dc0b91df5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classGHom.html">GHom</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGHom.html#aa8bf90af18a29f8369d00b74c09e194">invert</a> (const <a class="el" href="classGDDD.html">GDDD</a> &amp;pot) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns the predescessor homomorphism, using pot to determine variable domains  <a href="#aa8bf90af18a29f8369d00b74c09e194"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classGDDD.html">GDDD</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGHom.html#41745b72c666e9718ebf33c20d61f460">operator()</a> (const <a class="el" href="classGDDD.html">GDDD</a> &amp;d) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evaluation operator.  <a href="#41745b72c666e9718ebf33c20d61f460"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classGDDD.html">GDDD</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGHom.html#adf148bf7af0b8348f7a596d7ef425f2">eval</a> (const <a class="el" href="classGDDD.html">GDDD</a> &amp;d) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Evaluation function : users should use operator() instead of this.  <a href="#adf148bf7af0b8348f7a596d7ef425f2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGHom.html#cba7b975d2330f2837e899cb24e71819">skip_variable</a> (int var) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classGHom.html">GHom</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGHom.html#1c7b22844fd8aea4fd559077db4d323d">compose</a> (const <a class="el" href="classGHom.html">GHom</a> &amp;r) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGHom.html#bcb92252687a77f94a59dc468e7f2af0">refCounter</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Accessor to visualize the reference count of the concret instance.  <a href="#bcb92252687a77f94a59dc468e7f2af0"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Public Constructors</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGHom.html#aa7c39610e9d16460a40edf47c8d679b">GHom</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default public constructor.  <a href="#aa7c39610e9d16460a40edf47c8d679b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGHom.html#39794f56b351c24753a1213698a3c7d9">GHom</a> (const <a class="el" href="classMLHom.html">MLHom</a> &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Encapsulate an <a class="el" href="classMLHom.html">MLHom</a>, by setting a stop level for the upstream homomorphisms.  <a href="#39794f56b351c24753a1213698a3c7d9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGHom.html#db6c6fd0263b0d3ef896295d8df2d9d2">GHom</a> (const <a class="el" href="classGDDD.html">GDDD</a> &amp;d)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a constant <a class="el" href="classDDD.html" title="This class is the public interface for manipulating Data Decision Diagrams.">DDD</a> homomorphism.  <a href="#db6c6fd0263b0d3ef896295d8df2d9d2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGHom.html#04cf459f18217b62b59d3a99676f15d9">GHom</a> (int var, int val, const <a class="el" href="classGHom.html">GHom</a> &amp;h=<a class="el" href="classGHom.html#f17f84f00ffadd24e2f2894e0c8a2207">GHom::id</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create variable/value pair and left concatenate to a homomorphism.  <a href="#04cf459f18217b62b59d3a99676f15d9"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Comparisons for hash and map storage</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGHom.html#a7db8175b2ed7ca7ff42ed5d2bb51f60">operator==</a> (const <a class="el" href="classGHom.html">GHom</a> &amp;h) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Comparison between Homomorphisms.  <a href="#a7db8175b2ed7ca7ff42ed5d2bb51f60"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGHom.html#8cdb66c862560660eff92a569eb55015">operator!=</a> (const <a class="el" href="classGHom.html">GHom</a> &amp;h) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Comparison between Homomorphisms.  <a href="#8cdb66c862560660eff92a569eb55015"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGHom.html#f6be6ccb7775aeb9072c2c80ff7a7476">operator&lt;</a> (const <a class="el" href="classGHom.html">GHom</a> &amp;h) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Total ordering function between <a class="el" href="classHom.html" title="This is the user interface class to manipulate homomorphisms.">Hom</a>.  <a href="#f6be6ccb7775aeb9072c2c80ff7a7476"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGHom.html#be91da1f27fdc2b628969cf16215e7bb">is_selector</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This predicate is true if the homomorphism global behavior is only to prune some paths.  <a href="#be91da1f27fdc2b628969cf16215e7bb"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="classGHom.html">GHom</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGHom.html#d9200e0f513c70ceb92f8b72a7ce642b">add</a> (const std::set&lt; <a class="el" href="classGHom.html">GHom</a> &gt; &amp;set)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A constructor for a union of several homomorphisms.  <a href="#d9200e0f513c70ceb92f8b72a7ce642b"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static const <a class="el" href="classGHom.html">GHom</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGHom.html#f17f84f00ffadd24e2f2894e0c8a2207">id</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Elementary homomorphism <a class="el" href="classIdentity.html">Identity</a>, defined as a constant.  <a href="#f17f84f00ffadd24e2f2894e0c8a2207"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="class__GHom.html">_GHom</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGHom.html#ecc8fb38ce35a0e8e78e0c0a2838ec2e">concret</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The real implementation class.  <a href="#ecc8fb38ce35a0e8e78e0c0a2838ec2e"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGHom.html#e4d28fb19857b759f903d4c41a9f0368">Hom</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Open access to <a class="el" href="classHom.html" title="This is the user interface class to manipulate homomorphisms.">Hom</a> derived class.  <a href="#e4d28fb19857b759f903d4c41a9f0368"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGHom.html#bc44ade8b94f1ac5ede572ec1768465d">_GHom</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Open access to <a class="el" href="class__GHom.html" title="The concrete data class for Homomorphisms.">_GHom</a> based homomophisms.  <a href="#bc44ade8b94f1ac5ede572ec1768465d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classGHom.html">GHom</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGHom.html#d86dfe7582eeb38577dca18a0cb58783">fixpoint</a> (const <a class="el" href="classGHom.html">GHom</a> &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This operator applies its argument to a node until a fixpoint is reached.  <a href="#d86dfe7582eeb38577dca18a0cb58783"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classGHom.html">GHom</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGHom.html#d02a172cd3cc33885b9dddb06a1fbfc9">operator+</a> (const <a class="el" href="classGHom.html">GHom</a> &amp;, const <a class="el" href="classGHom.html">GHom</a> &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This operator creates an operation that is the union of two operations.  <a href="#d02a172cd3cc33885b9dddb06a1fbfc9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classGHom.html">GHom</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGHom.html#b4c897e330df47a425c599f665cf2ffd">operator&amp;</a> (const <a class="el" href="classGHom.html">GHom</a> &amp;, const <a class="el" href="classGHom.html">GHom</a> &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This operator creates an operation that is the composition of two operations.  <a href="#b4c897e330df47a425c599f665cf2ffd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classGHom.html">GHom</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGHom.html#bec978e9de787633d746c1616cf6942c">operator*</a> (const <a class="el" href="classGDDD.html">GDDD</a> &amp;, const <a class="el" href="classGHom.html">GHom</a> &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This operator creates an operation that is the intersection of an operation and a constant <a class="el" href="classDDD.html" title="This class is the public interface for manipulating Data Decision Diagrams.">DDD</a>.  <a href="#bec978e9de787633d746c1616cf6942c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classGHom.html">GHom</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGHom.html#1be385b3eedf23b7ba6473cf866aa3a6">operator*</a> (const <a class="el" href="classGHom.html">GHom</a> &amp;, const <a class="el" href="classGDDD.html">GDDD</a> &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This operator creates an operation that is the intersection of an operation and a constant <a class="el" href="classDDD.html" title="This class is the public interface for manipulating Data Decision Diagrams.">DDD</a>.  <a href="#1be385b3eedf23b7ba6473cf866aa3a6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classGHom.html">GHom</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGHom.html#8f83443dc2ba2ccaa68898193cdf98a2">operator^</a> (const <a class="el" href="classGDDD.html">GDDD</a> &amp;, const <a class="el" href="classGHom.html">GHom</a> &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is the left concatenantion operator, that adds a constant <a class="el" href="classDDD.html" title="This class is the public interface for manipulating Data Decision Diagrams.">DDD</a> above the operation.  <a href="#8f83443dc2ba2ccaa68898193cdf98a2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classGHom.html">GHom</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGHom.html#b8ce94c20f05403c297ff9591ea18919">operator^</a> (const <a class="el" href="classGHom.html">GHom</a> &amp;, const <a class="el" href="classGDDD.html">GDDD</a> &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is the right concatenantion operator, that adds a constant <a class="el" href="classDDD.html" title="This class is the public interface for manipulating Data Decision Diagrams.">DDD</a> below the operation.  <a href="#b8ce94c20f05403c297ff9591ea18919"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classGHom.html">GHom</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGHom.html#b64e9a1d83601035b2bafeb53e50989b">operator-</a> (const <a class="el" href="classGHom.html">GHom</a> &amp;, const <a class="el" href="classGDDD.html">GDDD</a> &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is a set difference constructor, only available for (hom - <a class="el" href="namespaceddd.html">ddd</a>), not hom - hom as that might not preserve linearity.  <a href="#b64e9a1d83601035b2bafeb53e50989b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGHom.html#4c6ed2147a63e065563824e6fb647cee">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classGHom.html">GHom</a> &amp;h)</td></tr>

<tr><td colspan="2"><br><h2>Memory Management</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGHom.html#a56524036de8c91ea495e51a715599b5">mark</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For garbage collection internals. Marks a <a class="el" href="classGHom.html" title="This class is the base class representing a homomorphism over DDD.">GHom</a> as in use in garbage collection phase.  <a href="#a56524036de8c91ea495e51a715599b5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGHom.html#2f795ee348657e5fe7a83158bf886919">hash</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For storage in a hash table.  <a href="#2f795ee348657e5fe7a83158bf886919"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGHom.html#85cadfee3758f316757eb2e641b3e608">statistics</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns unicity table current size. Gives the number of different <a class="el" href="class__GHom.html" title="The concrete data class for Homomorphisms.">_GHom</a> created and not yet destroyed.  <a href="#85cadfee3758f316757eb2e641b3e608"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGHom.html#74ea821dfa8f18942aea43f46da617af">pstats</a> (bool reinit=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prints some statistics to std::cout.  <a href="#74ea821dfa8f18942aea43f46da617af"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGHom.html#7bf18e5fe9fd3384e1c676b6e4f86a89">garbage</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For garbage collection.  <a href="#7bf18e5fe9fd3384e1c676b6e4f86a89"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
This class is the base class representing a homomorphism over <a class="el" href="classDDD.html" title="This class is the public interface for manipulating Data Decision Diagrams.">DDD</a>. 
<p>
A <a class="el" href="classDDD.html" title="This class is the public interface for manipulating Data Decision Diagrams.">DDD</a> homomorphism is a linear application that respects the better-defined relation (see ICATPN'2002 paper by Couvreur et al.). It comes with composition &amp;, union +, and intersection * operators to construct complex operations from two homomorphisms. It also comes with the <a class="el" href="classGHom.html#d86dfe7582eeb38577dca18a0cb58783" title="This operator applies its argument to a node until a fixpoint is reached.">fixpoint()</a> unary operator, that allows to implement saturation (see FORTE'05 paper by Couvreur &amp; Thierry-Mieg) This class does not implement reference counting : <a class="el" href="classGHom.html" title="This class is the base class representing a homomorphism over DDD.">GHom</a> are destroyed on MemoryManager::Garbage unless they are also referenced as <a class="el" href="classHom.html" title="This is the user interface class to manipulate homomorphisms.">Hom</a>. Note that this class is in fact a kind of smart pointer : operations are delegated on "concret" the true implementation class (of private hidden type <a class="el" href="class__GHom.html" title="The concrete data class for Homomorphisms.">_GHom</a>) that contains the data and has a single memory occurrence thanks to the unicity table. <hr><h2>Member Typedef Documentation</h2>
<a class="anchor" name="a6dc06d4106df676eeffdd02a24928ea"></a><!-- doxytag: member="GHom::NodeType" ref="a6dc06d4106df676eeffdd02a24928ea" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classGDDD.html">GDDD</a> <a class="el" href="classGDDD.html">GHom::NodeType</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="bea95e1c6d1d3c496bdfe72db17313c6"></a><!-- doxytag: member="GHom::GHom" ref="bea95e1c6d1d3c496bdfe72db17313c6" args="(const _GHom *_h)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GHom::GHom           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class__GHom.html">_GHom</a> *&nbsp;</td>
          <td class="paramname"> <em>_h</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A uncontrolled constructor used in internals. 
<p>
Made public for calls like return GHom(this) in <a class="el" href="classStrongHom.html#abfad0dce33e7ec55bf4d87f27e79907" title="Evaluation over an arbitrary arc of a SDD.">StrongHom::phi</a> definitions. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_h</em>&nbsp;</td><td>The pointer provided should point into the unicity table </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="3229c2d620541eaf310c1e8ac8430324"></a><!-- doxytag: member="GHom::GHom" ref="3229c2d620541eaf310c1e8ac8430324" args="(_GHom *_h)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GHom::GHom           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class__GHom.html">_GHom</a> *&nbsp;</td>
          <td class="paramname"> <em>_h</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
THIS VERSION IS DELIBERATELY UNIMPLEMENTED OTHERWISE bad calls like <a class="el" href="classGShom.html" title="This class is the base class for Homomorphisms over SDD.">GShom</a>(new myHom()) would promote to const <a class="el" href="class__GShom.html" title="The concrete data class for Homomorphisms.">_GShom</a> *_h and bypass unicity. 
<p>
User code prior to 20/05/08 would use this in the form : return new myHom(xx); This is now illegal as we take up memory allocation now, so the user should stack alloc and pass a reference as in GShom(const _GShom &amp;_h). Exceptionally, for efficiency, return this; in a phi user function is permitted hence public visibility of above GShom(const _GShom *_h); This signature is here to ensure link errors in old user code. 
</div>
</div><p>
<a class="anchor" name="e37412107f59f9297138936dc0b91df5"></a><!-- doxytag: member="GHom::GHom" ref="e37412107f59f9297138936dc0b91df5" args="(const _GHom &amp;_h)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GHom::GHom           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class__GHom.html">_GHom</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>_h</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
build a <a class="el" href="classGHom.html" title="This class is the base class representing a homomorphism over DDD.">GHom</a> from user provided homomorphisms such as <a class="el" href="classStrongHom.html" title="The abstract base class for user defined operations.">StrongHom</a>. 
<p>
This call ensures canonization of h 
</div>
</div><p>
<a class="anchor" name="aa7c39610e9d16460a40edf47c8d679b"></a><!-- doxytag: member="GHom::GHom" ref="aa7c39610e9d16460a40edf47c8d679b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GHom::GHom           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Default public constructor. 
<p>
Builds <a class="el" href="classIdentity.html">Identity</a> homomorphism : forall d in <a class="el" href="classDDD.html" title="This class is the public interface for manipulating Data Decision Diagrams.">DDD</a>, id(d) = d 
<p>Referenced by <a class="el" href="Hom_8cpp_source.html#l00955">add()</a>.</p>

</div>
</div><p>
<a class="anchor" name="39794f56b351c24753a1213698a3c7d9"></a><!-- doxytag: member="GHom::GHom" ref="39794f56b351c24753a1213698a3c7d9" args="(const MLHom &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GHom::GHom           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMLHom.html">MLHom</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>h</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Encapsulate an <a class="el" href="classMLHom.html">MLHom</a>, by setting a stop level for the upstream homomorphisms. 
<p>

</div>
</div><p>
<a class="anchor" name="db6c6fd0263b0d3ef896295d8df2d9d2"></a><!-- doxytag: member="GHom::GHom" ref="db6c6fd0263b0d3ef896295d8df2d9d2" args="(const GDDD &amp;d)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GHom::GHom           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGDDD.html">GDDD</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>d</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a constant <a class="el" href="classDDD.html" title="This class is the public interface for manipulating Data Decision Diagrams.">DDD</a> homomorphism. 
<p>
These are the basic building bricks of more complex operations. h(d1) (d2) = d1 Where d1 is a <a class="el" href="classDDD.html" title="This class is the public interface for manipulating Data Decision Diagrams.">DDD</a>, h(d1) a constant homomorphism and d2 an arbitrary <a class="el" href="classDDD.html" title="This class is the public interface for manipulating Data Decision Diagrams.">DDD</a>. 
</div>
</div><p>
<a class="anchor" name="04cf459f18217b62b59d3a99676f15d9"></a><!-- doxytag: member="GHom::GHom" ref="04cf459f18217b62b59d3a99676f15d9" args="(int var, int val, const GHom &amp;h=GHom::id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GHom::GHom           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGHom.html">GHom</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>h</em> = <code><a class="el" href="classGHom.html#f17f84f00ffadd24e2f2894e0c8a2207">GHom::id</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create variable/value pair and left concatenate to a homomorphism. 
<p>
h(var,val,g) (d) = DDD(var,val) ^ g(d). In other words : var -- val -&gt; g <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>var</em>&nbsp;</td><td>the variable index </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>the value associated to the variable </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>h</em>&nbsp;</td><td>the homomorphism to apply on successor node. Default is identity, so is equivalent to a left concatenation of a DDD(var,val). </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="d9200e0f513c70ceb92f8b72a7ce642b"></a><!-- doxytag: member="GHom::add" ref="d9200e0f513c70ceb92f8b72a7ce642b" args="(const std::set&lt; GHom &gt; &amp;set)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGHom.html">GHom</a> GHom::add           </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; <a class="el" href="classGHom.html">GHom</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>set</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A constructor for a union of several homomorphisms. 
<p>
Note that for canonisation and optimization reasons, union is an n-ary and commutative composition operator. Use of this constructor may be slightly more efficient than using operator+ multiple times. H({h1,h2, ..hn}) (d) = sum_i h_i (d). <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>set</em>&nbsp;</td><td>the set of homomorphisms to put in the union. </td></tr>
  </table>
</dl>
<dl class="todo" compact><dt><b><a class="el" href="todo.html#_todo000008">Todo:</a></b></dt><dd>std::set not very efficient for storage, replace by a sorted vector ? </dd></dl>

<p>References <a class="el" href="Hom_8cpp_source.html#l00048">canonical</a>, <a class="el" href="Hom_8h_source.html#l00119">GHom()</a>, and <a class="el" href="DDD_8h_source.html#l00135">GDDD::null</a>.</p>

<p>Referenced by <a class="el" href="Hom_8cpp_source.html#l00284">Add::invert()</a>, <a class="el" href="Hom_8cpp_source.html#l01108">operator+()</a>, and <a class="el" href="Hom_8cpp_source.html#l00322">Add::skip_variable()</a>.</p>

</div>
</div><p>
<a class="anchor" name="1c7b22844fd8aea4fd559077db4d323d"></a><!-- doxytag: member="GHom::compose" ref="1c7b22844fd8aea4fd559077db4d323d" args="(const GHom &amp;r) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGHom.html">GHom</a> GHom::compose           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGHom.html">GHom</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>r</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>References <a class="el" href="Hom_8cpp_source.html#l00764">_GHom::compose()</a>, and <a class="el" href="Hom_8h_source.html#l00094">concret</a>.</p>

<p>Referenced by <a class="el" href="MLHom_8cpp_source.html#l00160">nsMLHom::ConstantUp::eval()</a>.</p>

</div>
</div><p>
<a class="anchor" name="adf148bf7af0b8348f7a596d7ef425f2"></a><!-- doxytag: member="GHom::eval" ref="adf148bf7af0b8348f7a596d7ef425f2" args="(const GDDD &amp;d) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGDDD.html">GDDD</a> GHom::eval           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGDDD.html">GDDD</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>d</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Evaluation function : users should use operator() instead of this. 
<p>
This evaluation function does not use the cache, it is called in case of cache miss in the call to operator(). <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>d</em>&nbsp;</td><td>the argument <a class="el" href="classDDD.html" title="This class is the public interface for manipulating Data Decision Diagrams.">DDD</a> </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>h(d) </dd></dl>

<p>References <a class="el" href="Hom_8h_source.html#l00094">concret</a>, and <a class="el" href="Hom_8cpp_source.html#l00770">_GHom::eval_skip()</a>.</p>

<p>Referenced by <a class="el" href="DED_8cpp_source.html#l00535">_DED_Hom::eval()</a>.</p>

</div>
</div><p>
<a class="anchor" name="7bf18e5fe9fd3384e1c676b6e4f86a89"></a><!-- doxytag: member="GHom::garbage" ref="7bf18e5fe9fd3384e1c676b6e4f86a89" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GHom::garbage           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
For garbage collection. 
<p>
<em>WARNING</em> Do not use this function directly !! Use <a class="el" href="classMemoryManager.html#2e3ca8e74e2b79a6d32fc40f192ddef9" title="Garbage collection function.">MemoryManager::garbage()</a> to ensure proper reference counting and cache cleanup. Garbage collection algorithm is a simple two phase mark and sweep : in phase mark, all nodes with positive reference counts are marked, as well as their descendants, recursively. In phase sweep, all nodes which are unmarked are destroyed. This avoids maintaining reference counts during operation : only external references made through the <a class="el" href="classDDD.html" title="This class is the public interface for manipulating Data Decision Diagrams.">DDD</a> class are counted, and no recursive reference counting is needed. 
<p>References <a class="el" href="Cache_8hh_source.html#l00025">Cache&lt; HomType, NodeType &gt;::clear()</a>, <a class="el" href="Hom_8h_source.html#l00352">_GHom::marking</a>, and <a class="el" href="UniqueTable_8h_source.html#l00100">UniqueTable&lt; T &gt;::table</a>.</p>

</div>
</div><p>
<a class="anchor" name="2f795ee348657e5fe7a83158bf886919"></a><!-- doxytag: member="GHom::hash" ref="2f795ee348657e5fe7a83158bf886919" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t GHom::hash           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
For storage in a hash table. 
<p>

<p>References <a class="el" href="Hom_8h_source.html#l00094">concret</a>, and <a class="el" href="hashfunc_8hh_source.html#l00059">ddd::knuth32_hash()</a>.</p>

<p>Referenced by <a class="el" href="SHom_8cpp_source.html#l00441">sns::LocalApply::hash()</a>, <a class="el" href="MLHom_8cpp_source.html#l00150">nsMLHom::ConstantUp::hash()</a>, <a class="el" href="MLHom_8cpp_source.html#l00120">nsMLHom::GHomAdapter::hash()</a>, <a class="el" href="Hom_8cpp_source.html#l00661">Fixpoint::hash()</a>, <a class="el" href="Hom_8cpp_source.html#l00601">Minus::hash()</a>, <a class="el" href="Hom_8cpp_source.html#l00560">RightConcat::hash()</a>, <a class="el" href="Hom_8cpp_source.html#l00519">LeftConcat::hash()</a>, <a class="el" href="Hom_8cpp_source.html#l00446">Compose::hash()</a>, <a class="el" href="Hom_8cpp_source.html#l00206">NotCond::hash()</a>, <a class="el" href="Hom_8cpp_source.html#l00140">Mult::hash()</a>, and <a class="el" href="DED_8cpp_source.html#l00526">_DED_Hom::hash()</a>.</p>

</div>
</div><p>
<a class="anchor" name="aa8bf90af18a29f8369d00b74c09e194"></a><!-- doxytag: member="GHom::invert" ref="aa8bf90af18a29f8369d00b74c09e194" args="(const GDDD &amp;pot) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGHom.html">GHom</a> GHom::invert           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGDDD.html">GDDD</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pot</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
returns the predescessor homomorphism, using pot to determine variable domains 
<p>

<p>References <a class="el" href="Hom_8h_source.html#l00094">concret</a>, and <a class="el" href="Hom_8h_source.html#l00380">_GHom::invert()</a>.</p>

<p>Referenced by <a class="el" href="SHom_8cpp_source.html#l00445">sns::LocalApply::invert()</a>, <a class="el" href="Hom_8cpp_source.html#l00674">Fixpoint::invert()</a>, <a class="el" href="Hom_8cpp_source.html#l00622">Minus::invert()</a>, <a class="el" href="Hom_8cpp_source.html#l00453">Compose::invert()</a>, and <a class="el" href="Hom_8cpp_source.html#l00151">Mult::invert()</a>.</p>

</div>
</div><p>
<a class="anchor" name="be91da1f27fdc2b628969cf16215e7bb"></a><!-- doxytag: member="GHom::is_selector" ref="be91da1f27fdc2b628969cf16215e7bb" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool GHom::is_selector           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This predicate is true if the homomorphism global behavior is only to prune some paths. 
<p>

<p>References <a class="el" href="Hom_8h_source.html#l00094">concret</a>, and <a class="el" href="Hom_8h_source.html#l00374">_GHom::is_selector()</a>.</p>

<p>Referenced by <a class="el" href="SHom_8cpp_source.html#l00402">sns::LocalApply::is_selector()</a>, <a class="el" href="Hom_8cpp_source.html#l00680">Fixpoint::is_selector()</a>, <a class="el" href="Hom_8cpp_source.html#l00617">Minus::is_selector()</a>, <a class="el" href="Hom_8cpp_source.html#l00466">Compose::is_selector()</a>, <a class="el" href="Hom_8cpp_source.html#l00156">Mult::is_selector()</a>, <a class="el" href="Hom_8cpp_source.html#l01074">ITE()</a>, and <a class="el" href="Hom_8cpp_source.html#l01084">operator!()</a>.</p>

</div>
</div><p>
<a class="anchor" name="a56524036de8c91ea495e51a715599b5"></a><!-- doxytag: member="GHom::mark" ref="a56524036de8c91ea495e51a715599b5" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GHom::mark           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
For garbage collection internals. Marks a <a class="el" href="classGHom.html" title="This class is the base class representing a homomorphism over DDD.">GHom</a> as in use in garbage collection phase. 
<p>

<p>References <a class="el" href="Hom_8h_source.html#l00094">concret</a>, <a class="el" href="Hom_8h_source.html#l00423">_GHom::mark()</a>, and <a class="el" href="Hom_8h_source.html#l00352">_GHom::marking</a>.</p>

<p>Referenced by <a class="el" href="SHom_8cpp_source.html#l00437">sns::LocalApply::mark()</a>, <a class="el" href="MemoryManager_8h_source.html#l00063">MemoryManager::mark()</a>, <a class="el" href="Hom_8cpp_source.html#l00753">Fixpoint::mark()</a>, <a class="el" href="Hom_8cpp_source.html#l00612">Minus::mark()</a>, <a class="el" href="Hom_8cpp_source.html#l00578">RightConcat::mark()</a>, <a class="el" href="Hom_8cpp_source.html#l00535">LeftConcat::mark()</a>, <a class="el" href="Hom_8cpp_source.html#l00477">Compose::mark()</a>, <a class="el" href="Hom_8cpp_source.html#l00202">NotCond::mark()</a>, and <a class="el" href="Hom_8cpp_source.html#l00163">Mult::mark()</a>.</p>

</div>
</div><p>
<a class="anchor" name="8cdb66c862560660eff92a569eb55015"></a><!-- doxytag: member="GHom::operator!=" ref="8cdb66c862560660eff92a569eb55015" args="(const GHom &amp;h) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool GHom::operator!=           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGHom.html">GHom</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>h</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Comparison between Homomorphisms. 
<p>
Note that comparison is based on "concret" address in unicity table. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>h</em>&nbsp;</td><td>the hom to compare to </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if the nodes are NOT equal. </dd></dl>

<p>References <a class="el" href="Hom_8h_source.html#l00094">concret</a>.</p>

</div>
</div><p>
<a class="anchor" name="41745b72c666e9718ebf33c20d61f460"></a><!-- doxytag: member="GHom::operator()" ref="41745b72c666e9718ebf33c20d61f460" args="(const GDDD &amp;d) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGDDD.html">GDDD</a> GHom::operator()           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGDDD.html">GDDD</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>d</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Evaluation operator. 
<p>
Homomorphisms overload operator(), so they can be directly applied to <a class="el" href="classDDD.html" title="This class is the public interface for manipulating Data Decision Diagrams.">DDD</a> nodes. Note that evaluation through this operator uses and updates a cache. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>d</em>&nbsp;</td><td>the <a class="el" href="classDDD.html" title="This class is the public interface for manipulating Data Decision Diagrams.">DDD</a> to apply this h to. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>h(d), the result of applying this h to d. </dd></dl>

<p>References <a class="el" href="Hom_8h_source.html#l00094">concret</a>, <a class="el" href="class__GHom.html#e416cdc5db5bd4d6ec2efe1ea7784ba2">_GHom::eval()</a>, <a class="el" href="Hom_8h_source.html#l00356">_GHom::immediat</a>, <a class="el" href="Cache_8hh_source.html#l00043">Cache&lt; HomType, NodeType &gt;::insert()</a>, and <a class="el" href="DDD_8h_source.html#l00135">GDDD::null</a>.</p>

</div>
</div><p>
<a class="anchor" name="f6be6ccb7775aeb9072c2c80ff7a7476"></a><!-- doxytag: member="GHom::operator&lt;" ref="f6be6ccb7775aeb9072c2c80ff7a7476" args="(const GHom &amp;h) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool GHom::operator&lt;           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGHom.html">GHom</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>h</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Total ordering function between <a class="el" href="classHom.html" title="This is the user interface class to manipulate homomorphisms.">Hom</a>. 
<p>
Note that comparison is based on "concret" address in unicity table. This ordering is necessary for hash and map storage of <a class="el" href="classGHom.html" title="This class is the base class representing a homomorphism over DDD.">GHom</a>. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>h</em>&nbsp;</td><td>the node to compare to </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if argument h is greater than "this". </dd></dl>

<p>References <a class="el" href="Hom_8h_source.html#l00094">concret</a>.</p>

</div>
</div><p>
<a class="anchor" name="a7db8175b2ed7ca7ff42ed5d2bb51f60"></a><!-- doxytag: member="GHom::operator==" ref="a7db8175b2ed7ca7ff42ed5d2bb51f60" args="(const GHom &amp;h) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool GHom::operator==           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGHom.html">GHom</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>h</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Comparison between Homomorphisms. 
<p>
Note that comparison is based on "concret" address in unicity table. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>h</em>&nbsp;</td><td>the hom to compare to </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if the nodes are equal. </dd></dl>

<p>References <a class="el" href="Hom_8h_source.html#l00094">concret</a>.</p>

</div>
</div><p>
<a class="anchor" name="74ea821dfa8f18942aea43f46da617af"></a><!-- doxytag: member="GHom::pstats" ref="74ea821dfa8f18942aea43f46da617af" args="(bool reinit=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GHom::pstats           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>reinit</em> = <code>true</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Prints some statistics to std::cout. 
<p>
Mostly used in debug and development phase. <dl class="todo" compact><dt><b><a class="el" href="todo.html#_todo000009">Todo:</a></b></dt><dd>allow output in other place than cout. Clean up output. </dd></dl>

<p>References <a class="el" href="UniqueTable_8h_source.html#l00128">UniqueTable&lt; T &gt;::size()</a>, and <a class="el" href="UniqueTable_8h_source.html#l00100">UniqueTable&lt; T &gt;::table</a>.</p>

</div>
</div><p>
<a class="anchor" name="bcb92252687a77f94a59dc468e7f2af0"></a><!-- doxytag: member="GHom::refCounter" ref="bcb92252687a77f94a59dc468e7f2af0" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int GHom::refCounter           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Accessor to visualize the reference count of the concret instance. 
<p>
See <a class="el" href="class__GHom.html#8d389676b61e25c080e010bccbaf1f71" title="For garbage collection.">_GHom::refCounter</a> for details. 
<p>References <a class="el" href="Hom_8h_source.html#l00094">concret</a>, and <a class="el" href="Hom_8h_source.html#l00347">_GHom::refCounter</a>.</p>

</div>
</div><p>
<a class="anchor" name="cba7b975d2330f2837e899cb24e71819"></a><!-- doxytag: member="GHom::skip_variable" ref="cba7b975d2330f2837e899cb24e71819" args="(int var) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool GHom::skip_variable           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>var</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>References <a class="el" href="Hom_8h_source.html#l00094">concret</a>, and <a class="el" href="Hom_8h_source.html#l00367">_GHom::skip_variable()</a>.</p>

<p>Referenced by <a class="el" href="MLHom_8cpp_source.html#l00126">nsMLHom::GHomAdapter::skip_variable()</a>.</p>

</div>
</div><p>
<a class="anchor" name="85cadfee3758f316757eb2e641b3e608"></a><!-- doxytag: member="GHom::statistics" ref="85cadfee3758f316757eb2e641b3e608" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int GHom::statistics           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns unicity table current size. Gives the number of different <a class="el" href="class__GHom.html" title="The concrete data class for Homomorphisms.">_GHom</a> created and not yet destroyed. 
<p>

<p>References <a class="el" href="UniqueTable_8h_source.html#l00128">UniqueTable&lt; T &gt;::size()</a>.</p>

<p>Referenced by <a class="el" href="statistic_8cpp_source.html#l00048">Statistic::load()</a>, and <a class="el" href="MemoryManager_8h_source.html#l00050">MemoryManager::nbHom()</a>.</p>

</div>
</div><p>
<hr><h2>Friends And Related Function Documentation</h2>
<a class="anchor" name="bc44ade8b94f1ac5ede572ec1768465d"></a><!-- doxytag: member="GHom::_GHom" ref="bc44ade8b94f1ac5ede572ec1768465d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="class__GHom.html">_GHom</a><code> [friend]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Open access to <a class="el" href="class__GHom.html" title="The concrete data class for Homomorphisms.">_GHom</a> based homomophisms. 
<p>

</div>
</div><p>
<a class="anchor" name="d86dfe7582eeb38577dca18a0cb58783"></a><!-- doxytag: member="GHom::fixpoint" ref="d86dfe7582eeb38577dca18a0cb58783" args="(const GHom &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGHom.html">GHom</a> fixpoint           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGHom.html">GHom</a> &amp;&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This operator applies its argument to a node until a fixpoint is reached. 
<p>
Application consists in : while ( h(d) != d ) d = h(d); Where d is a <a class="el" href="classDDD.html" title="This class is the public interface for manipulating Data Decision Diagrams.">DDD</a> and h a homomorphism.<p>
This new unary operator is introduced to implement local saturation in transition relation evaluation. Proper use of fixpoint allows to effectively tackle the intermediate size problem of decision diagram based representations. Note that evaluation simply iterates until a fixpoint is reached, thus to cumulate new states with previously reached it should be combined with <a class="el" href="classGShom.html#b283e77d8df01c595ad31652d3895090" title="Elementary SDD homomorphism identity. Applied to any SDD d, it returns d.">GShom::id</a> as in<p>
fixpoint ( h + <a class="el" href="classGShom.html#b283e77d8df01c595ad31652d3895090" title="Elementary SDD homomorphism identity. Applied to any SDD d, it returns d.">GShom::id</a> ) 
</div>
</div><p>
<a class="anchor" name="e4d28fb19857b759f903d4c41a9f0368"></a><!-- doxytag: member="GHom::Hom" ref="e4d28fb19857b759f903d4c41a9f0368" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classHom.html">Hom</a><code> [friend]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Open access to <a class="el" href="classHom.html" title="This is the user interface class to manipulate homomorphisms.">Hom</a> derived class. 
<p>

</div>
</div><p>
<a class="anchor" name="b4c897e330df47a425c599f665cf2ffd"></a><!-- doxytag: member="GHom::operator&amp;" ref="b4c897e330df47a425c599f665cf2ffd" args="(const GHom &amp;, const GHom &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGHom.html">GHom</a> operator&amp;           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGHom.html">GHom</a> &amp;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGHom.html">GHom</a> &amp;&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This operator creates an operation that is the composition of two operations. 
<p>
(h &amp; g) (d) = h( g(d) ) ; Where g,h are homomorphisms and d is a <a class="el" href="classDDD.html" title="This class is the public interface for manipulating Data Decision Diagrams.">DDD</a>.<p>
Semantics : (h1 &amp; h2) (d) = h1( h2(d) ). 
</div>
</div><p>
<a class="anchor" name="1be385b3eedf23b7ba6473cf866aa3a6"></a><!-- doxytag: member="GHom::operator*" ref="1be385b3eedf23b7ba6473cf866aa3a6" args="(const GHom &amp;, const GDDD &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGHom.html">GHom</a> operator*           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGHom.html">GHom</a> &amp;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGDDD.html">GDDD</a> &amp;&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This operator creates an operation that is the intersection of an operation and a constant <a class="el" href="classDDD.html" title="This class is the public interface for manipulating Data Decision Diagrams.">DDD</a>. 
<p>
(h * d1) (d2) = h(d2) * d1 ; Where h is a homomorphism and d1, d2 are <a class="el" href="classDDD.html" title="This class is the public interface for manipulating Data Decision Diagrams.">DDD</a>.<p>
Semantics : (d1 * h) (d) = d1 * h(d) 
</div>
</div><p>
<a class="anchor" name="bec978e9de787633d746c1616cf6942c"></a><!-- doxytag: member="GHom::operator*" ref="bec978e9de787633d746c1616cf6942c" args="(const GDDD &amp;, const GHom &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGHom.html">GHom</a> operator*           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGDDD.html">GDDD</a> &amp;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGHom.html">GHom</a> &amp;&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This operator creates an operation that is the intersection of an operation and a constant <a class="el" href="classDDD.html" title="This class is the public interface for manipulating Data Decision Diagrams.">DDD</a>. 
<p>
(d1 * h) (d2) = d1 * h(d2) ; Where h is a homomorphism and d1, d2 are <a class="el" href="classDDD.html" title="This class is the public interface for manipulating Data Decision Diagrams.">DDD</a>.<p>
Semantics : (h * d1) (d) = h(d) * d1 
</div>
</div><p>
<a class="anchor" name="d02a172cd3cc33885b9dddb06a1fbfc9"></a><!-- doxytag: member="GHom::operator+" ref="d02a172cd3cc33885b9dddb06a1fbfc9" args="(const GHom &amp;, const GHom &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGHom.html">GHom</a> operator+           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGHom.html">GHom</a> &amp;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGHom.html">GHom</a> &amp;&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This operator creates an operation that is the union of two operations. 
<p>
By definition, as homomorphism are linear, (h+g) (d) = h(d) + g(d) ; Where g,h are homomorphisms and d is a <a class="el" href="classDDD.html" title="This class is the public interface for manipulating Data Decision Diagrams.">DDD</a>.<p>
See also <a class="el" href="classGShom.html#d8306dea11f1ee748a8e6724c83e5b8d">GShom::add()</a>. This commutative operation computes a homomorphism that evaluates as the sum of two homomorphism.<p>
Semantics : (h1 + h2) (d) = h1(d) + h2(d). 
</div>
</div><p>
<a class="anchor" name="b64e9a1d83601035b2bafeb53e50989b"></a><!-- doxytag: member="GHom::operator&#45;" ref="b64e9a1d83601035b2bafeb53e50989b" args="(const GHom &amp;, const GDDD &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGHom.html">GHom</a> operator-           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGHom.html">GHom</a> &amp;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGDDD.html">GDDD</a> &amp;&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This is a set difference constructor, only available for (hom - <a class="el" href="namespaceddd.html">ddd</a>), not hom - hom as that might not preserve linearity. 
<p>
(h - d1) (d2) = h(d2) - d1 Where h is a homomorphism and d1, d2 are <a class="el" href="classDDD.html" title="This class is the public interface for manipulating Data Decision Diagrams.">DDD</a>.<p>
Note that this operation is not commutative, nor is it <em>linear</em>. This means the difference of two linear homomorphisms is not necessarily linear; (h1 - h2) (d) is not necessarily equal to h1(d) - h2(d). Therefore this operator is not defined for composition of two homomorphisms, only for a constant and a homomorphism.<p>
Semantics : (h - d1) (d) = h(d) - d1 
</div>
</div><p>
<a class="anchor" name="4c6ed2147a63e065563824e6fb647cee"></a><!-- doxytag: member="GHom::operator&lt;&lt;" ref="4c6ed2147a63e065563824e6fb647cee" args="(std::ostream &amp;os, const GHom &amp;h)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt;           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGHom.html">GHom</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>h</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="b8ce94c20f05403c297ff9591ea18919"></a><!-- doxytag: member="GHom::operator^" ref="b8ce94c20f05403c297ff9591ea18919" args="(const GHom &amp;, const GDDD &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGHom.html">GHom</a> operator^           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGHom.html">GHom</a> &amp;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGDDD.html">GDDD</a> &amp;&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This is the right concatenantion operator, that adds a constant <a class="el" href="classDDD.html" title="This class is the public interface for manipulating Data Decision Diagrams.">DDD</a> below the operation. 
<p>
(h ^ d1) (d2) = h(d1) ^ d2 Where h is a homomorphism and d1, d2 are <a class="el" href="classDDD.html" title="This class is the public interface for manipulating Data Decision Diagrams.">DDD</a>.<p>
This is used to construct new nodes, and has the same efficiency issue as left concatenation.<p>
Semantics : (h ^ d1) (d) = h(d) ^ d1 
</div>
</div><p>
<a class="anchor" name="8f83443dc2ba2ccaa68898193cdf98a2"></a><!-- doxytag: member="GHom::operator^" ref="8f83443dc2ba2ccaa68898193cdf98a2" args="(const GDDD &amp;, const GHom &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGHom.html">GHom</a> operator^           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGDDD.html">GDDD</a> &amp;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGHom.html">GHom</a> &amp;&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This is the left concatenantion operator, that adds a constant <a class="el" href="classDDD.html" title="This class is the public interface for manipulating Data Decision Diagrams.">DDD</a> above the operation. 
<p>
(d1 ^ h) (d2) = d1 ^ h(d2) Where h is a homomorphism and d1, d2 are <a class="el" href="classDDD.html" title="This class is the public interface for manipulating Data Decision Diagrams.">DDD</a>.<p>
Note that this is inherently inefficient, the nodes of d1 are constructed, but the result a priori will not contain them, unless h(d) == <a class="el" href="classGSDD.html#4aa86c09040738368d7fc9fcf35897a9" title="The accepting terminal. This is the basic leaf for accepted sequences.">GSDD::one</a>.<p>
Semantics : (d1 ^ h) (d) = d1 ^ h(d) 
</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="ecc8fb38ce35a0e8e78e0c0a2838ec2e"></a><!-- doxytag: member="GHom::concret" ref="ecc8fb38ce35a0e8e78e0c0a2838ec2e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class__GHom.html">_GHom</a>* <a class="el" href="classGHom.html#ecc8fb38ce35a0e8e78e0c0a2838ec2e">GHom::concret</a><code> [private]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The real implementation class. 
<p>
All true operations are delagated on this pointer. Construction/destruction take care of ensuring concret is only instantiated once in memory. 
<p>Referenced by <a class="el" href="Hom_8cpp_source.html#l00915">compose()</a>, <a class="el" href="Hom_8cpp_source.html#l00945">eval()</a>, <a class="el" href="Hom_8h_source.html#l00432">_GHom::get_concret()</a>, <a class="el" href="Hom_8h_source.html#l00205">hash()</a>, <a class="el" href="Hom_8cpp_source.html#l01013">Hom::Hom()</a>, <a class="el" href="Hom_8cpp_source.html#l00919">invert()</a>, <a class="el" href="Hom_8cpp_source.html#l01053">is_selector()</a>, <a class="el" href="Hom_8cpp_source.html#l00976">mark()</a>, <a class="el" href="Hom_8h_source.html#l00151">operator!=()</a>, <a class="el" href="Hom_8cpp_source.html#l00926">operator()()</a>, <a class="el" href="Hom_8h_source.html#l00156">operator&lt;()</a>, <a class="el" href="Hom_8cpp_source.html#l01159">operator&lt;&lt;()</a>, <a class="el" href="Hom_8cpp_source.html#l01036">Hom::operator=()</a>, <a class="el" href="Hom_8h_source.html#l00147">operator==()</a>, <a class="el" href="Hom_8cpp_source.html#l00951">refCounter()</a>, <a class="el" href="Hom_8cpp_source.html#l00911">skip_variable()</a>, and <a class="el" href="Hom_8cpp_source.html#l01029">Hom::~Hom()</a>.</p>

</div>
</div><p>
<a class="anchor" name="f17f84f00ffadd24e2f2894e0c8a2207"></a><!-- doxytag: member="GHom::id" ref="f17f84f00ffadd24e2f2894e0c8a2207" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classGHom.html">GHom</a> <a class="el" href="classGHom.html#f17f84f00ffadd24e2f2894e0c8a2207">GHom::id</a><code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Elementary homomorphism <a class="el" href="classIdentity.html">Identity</a>, defined as a constant. 
<p>
id(d) = d 
<p>Referenced by <a class="el" href="SHom_8cpp_source.html#l02154">buildUnionParameters()</a>, <a class="el" href="MLHom_8cpp_source.html#l00132">nsMLHom::GHomAdapter::eval()</a>, <a class="el" href="MLHom_8cpp_source.html#l00067">nsMLHom::Identity::eval()</a>, <a class="el" href="Hom_8cpp_source.html#l01059">fixpoint()</a>, <a class="el" href="Hom_8cpp_source.html#l00266">Add::get_have_id()</a>, <a class="el" href="Hom_8cpp_source.html#l00674">Fixpoint::invert()</a>, <a class="el" href="Hom_8cpp_source.html#l00622">Minus::invert()</a>, <a class="el" href="Hom_8cpp_source.html#l00151">Mult::invert()</a>, <a class="el" href="SHom_8cpp_source.html#l02081">localApply()</a>, and <a class="el" href="Hom_8cpp_source.html#l01093">operator&amp;()</a>.</p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="Hom_8h_source.html">Hom.h</a><li><a class="el" href="Hom_8cpp.html">Hom.cpp</a></ul>
</div>
<hr size="1">
Please <b>comment</b> this page and <b>report errors</b> about it on
<a href="http://ddd.lip6.fr/wiki/RefDocComments">the RefDocComments page</a>.
<br><address style="align: right;"><small>
Generated on Thu May 27 15:02:45 2010 for DDD by <a href="http://www.doxygen.org/index.html"><img src="doxygen.png" alt="doxygen" align="middle" border=0></a> 1.5.9</small></address>
</body>
</html>
